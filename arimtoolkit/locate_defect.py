#!/usr/bin/env python3
# encoding: utf-8
"""
Show the direct views and allow the user to save the defect conf with a click.
Input
-----
Conf file

Output
------
conf.d/15_defect_loc.yaml
    
"""
import logging
from collections import OrderedDict
import yaml

import matplotlib.pyplot as plt
import numpy as np

import arim
import arim.ray
import arim.im
import arim.models.block_in_immersion as bim
import arim.plot as aplt

from . import common

# %% Load configuration

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logging.getLogger("arim").setLevel(logging.INFO)


def locate_defect(dataset_name, save):
    # %%
    conf = arim.io.load_conf(dataset_name)
    # conf['grid']['pixel_size'] = 2e-3
    aplt.conf["savefig"] = False

    result_dir = conf["result_dir"]

    logger.info(f"dataset_name: {dataset_name}")

    # Load frame
    frame = common.load_frame(conf, apply_filter=True, expand=True)

    # Make grid
    z_backwall = conf["backwall"]["z"]
    assert not np.isnan(z_backwall)

    grid = common.make_grid_tfm(conf)
    grid_p = grid.to_oriented_points()
    probe_p = frame.probe.to_oriented_points()

    # Make views
    views = bim.make_views(
        frame.examination_object,
        probe_p,
        grid_p,
        tfm_unique_only=True,
        max_number_of_reflection=0,
    )
    # views = {'L-L':views['L-L']}
    # if conf['views_to_use'] != 'all':
    #    views = OrderedDict([(viewname, view) for viewname, view in views.items()
    #                         if viewname in conf['views_to_use']])

    # %% Perform ray tracing

    arim.ray.ray_tracing(views.values(), convert_to_fortran_order=True)

    # %% Run TFM

    tfms = OrderedDict()
    for i, view in enumerate(views.values()):
        with arim.helpers.timeit("TFM {}".format(view.name), logger=logger):
            tfms[view.name] = arim.im.tfm.tfm_for_view(frame, grid, view, fillvalue=0.0)

    # %% Matplotlib event handler
    out_file = result_dir / "conf.d/15_defect_loc.yaml"

    def save_defect_loc_on_click(event):
        if event.button != 1:
            return

        # use .item() to get a Python type instead of Numpy type
        data = dict(
            scatterer=dict(
                location=dict(x=event.xdata.item(), y=0.0, z=event.ydata.item())
            )
        )
        out_content = "# generated by locate_defect.py\n" + yaml.dump(
            data, default_flow_style=False
        )

        if save:
            with out_file.open("w", encoding="utf8") as stream:
                stream.write(out_content)

        print(f"----- Output: {out_file}")
        print(out_content)
        print("-----")

    # %% Plot all TFM

    cids = []

    for i, (viewname, view) in enumerate(views.items()):
        tfm = tfms[viewname]

        ref_db = None
        clim = [-80.0, 0.0]

        ax, _ = aplt.plot_tfm(
            tfm,
            clim=clim,
            scale="db",
            ref_db=ref_db,
            title=f"TFM {viewname} - Left-click on defect to write conf",
            filename=str(result_dir / f"tfm_{i:02}_{viewname}"),
            figsize=(10, 5),
        )

        cid = ax.figure.canvas.mpl_connect(
            "button_press_event", save_defect_loc_on_click
        )
        cids.append(cid)

    return cids


#    if save:
#    with conf_file.open('w', encoding='utf8') as stream:
#        stream.write('# generated by measure_probe_loc.py\n')
#        yaml.dump(dict(new_conf), stream=stream, default_flow_style=False)
#
#    print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
#          ('double' if event.dblclick else 'single', event.button,
#           event.x, event.y, event.xdata, event.ydata))

# %%
if __name__ == "__main__":
    args = common.argparser(__doc__).parse_args()
    dataset_name = args.dataset_name
    save = args.save

    cids = locate_defect(dataset_name, save)

    # Block script until windows are closed.
    plt.show()
